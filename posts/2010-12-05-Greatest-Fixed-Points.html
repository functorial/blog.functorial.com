<!DOCTYPE html>

<html>
    <head>
        <title>functorial.com - Greatest Fixed Points and Anamorphisms in C#</title>
        <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu+Mono"></link>
        <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Lato:300,400,700"></link>
        <link rel="stylesheet" type="text/css" href="../css/default.css"></link>

        <script type="text/x-mathjax-config"> 
            MathJax.Hub.Config({
                config: ["MMLorHTML.js"],
                jax: ["input/TeX"],
                extensions: ["tex2jax.js"],
                TeX: { 
                    extensions: ["AMSmath.js", "AMSsymbols.js", "noErrors.js","noUndefined.js"] 
                },
                tex2jax: {
                    inlineMath: [['$','$'], ['\\(','\\)']]
                }
            }); 
        </script> 
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script> 
    </head>
    <body>
        <div id="wrapper">
            <h1>Greatest Fixed Points and Anamorphisms in C#</h1>

            <div id="navigation">
                <a href="../index.html">Home</a>
                <a href="../feed.xml">RSS Feed</a>
            </div>

            <p>As promised in my last post, I'm now going to go over how to encode greatest fixed point types and their anamorphisms in C# using existentials.</p>
<p>A recap: we use the isomorphisms</p>
<blockquote>
<p>exists X. T ~ forall R. (forall X. T -&gt; R) -&gt; R</p>
<p>\(pack X x). \R. \f. f x</p>
</blockquote>
<p>and</p>
<blockquote>
<p>Nu F ~ exists X. X * (X -&gt; F X)</p>
<p>\x. pack x out</p>
</blockquote>
<p>where the second morphism has an inverse given by</p>
<blockquote>
<p>\(pack X x). \f. ana f x</p>
</blockquote>
<p>where <code>ana f</code> denotes the anamorphism generated by <code>f</code>.</p>
<p>As an example, we are going to treat the case of infinite streams over an alphabet A:</p>
<blockquote>
<p>Stream A := Nu (\X. A * X)</p>
</blockquote>
<p>Let's first interpret the second isomorphism above in this context. We have</p>
<blockquote>
<p>Stream A ~ exists X. X * (X -&gt; X * A)</p>
</blockquote>
<p>The packed type here acts as an indicator of the position in the stream. We could take <code>X = int</code>. For constant streams, we could even let <code>X = ()</code>, the unit type. Then, we can interpret the existential package <code>pack X a f</code> as the stream with first few elements <code>a</code>, <code>outr (f a)</code>, <code>outr f (outr (f a))</code>, ...</p>
<p>Let's translate this into C#. First, our definition of a stream, using the first isomorphism above to encode existentials as universals:</p>
<pre><code>struct StreamF&lt;A, T&gt;
{
    public T Seed { get; set; }
    public Func&lt;T, Tuple&lt;T, A&gt;&gt; Generator { get; set; }
}

interface StreamFunction&lt;A, R&gt;
{
    R Apply&lt;T&gt;(StreamF&lt;A, T&gt; n);
}

interface Stream&lt;A&gt;
{
    R Apply&lt;R&gt;(StreamFunction&lt;A, R&gt; f);
}</code></pre>
<p>With that definition, we can proceed to define anamorphisms in the way one would expect:</p>
<pre><code>class AnaStream&lt;A, T&gt; : Stream&lt;A&gt;
{
    private readonly StreamF&lt;A, T&gt; sf;


    public AnaStream(StreamF&lt;A, T&gt; sf)
    {
        this.sf = sf;
    }

    public R Apply&lt;R&gt;(StreamFunction&lt;A, R&gt; f)
    {
        return f.Apply&lt;T&gt;(sf);
    }
}

public static Func&lt;T, Stream&lt;A&gt;&gt; Ana&lt;A, T&gt;(Func&lt;T, Tuple&lt;T, A&gt;&gt; generator)
{
    return seed =&gt; new AnaStream&lt;A, T&gt;(new StreamF&lt;A, T&gt;
    {
        Seed = seed,
        Generator = generator
    });
}</code></pre>
<p>With anamorphisms under our belt, we can now define constant streams with ease:</p>
<pre><code>public static Stream&lt;T&gt; Const&lt;T&gt;(T t)
{
    return Ana&lt;T, Unit&gt;(u =&gt; Tuple.Create&lt;Unit, T&gt;(u, t))(new Unit());
}</code></pre>
<p>with <code>Unit</code> here denoting any one-point type.</p>
<p>Consing an element onto the front of a stream is a little tricky. The idea is to replace the underlying type of the existential package T with the type <code>Maybe T := 1 + T</code>. Here the unit type corresponds to the head of the new stream and the T corresponds to the tail. In order to get at the underlying type of the package, we have to wrap any <code>StreamFunction&lt;A&gt;</code> object which will be responsible for unpacking the existential package:</p>
<pre><code>class ConsFunction&lt;A, R&gt; : StreamFunction&lt;A, R&gt;
{
    private A head;
    private StreamFunction&lt;A, R&gt; tailFunction;

    public ConsFunction(StreamFunction&lt;A, R&gt; tailFunction, A head)
    {
        this.head = head;
        this.tailFunction = tailFunction;
    }

    public R Apply&lt;T&gt;(StreamF&lt;A, T&gt; n)
    {

        return tailFunction.Apply&lt;Either&lt;Unit, T&gt;&gt;(new StreamF&lt;A, Either&lt;Unit, T&gt;&gt;
        {
            Seed = Either&lt;Unit, T&gt;.inl(new Unit()),
            Generator = pair =&gt; pair.Case(
                u =&gt; Tuple.Create&lt;Either&lt;Unit, T&gt;, A&gt;(
                    Either&lt;Unit, T&gt;.inr(n.Seed), head),
                new Func&lt;T, Tuple&lt;Either&lt;Unit, T&gt;, A&gt;&gt;(t =&gt;
                {
                    Tuple&lt;T, A&gt; next = n.Generator(t);
                    return Tuple.Create&lt;Either&lt;Unit, T&gt;, A&gt;(
                        Either&lt;Unit, T&gt;.inr(next.Item1), next.Item2);
                }))
        });
    }
}

class ConsStream&lt;A&gt; : Stream&lt;A&gt;
{
    private Stream&lt;A&gt; tail;
    private A head;

    public ConsStream(Stream&lt;A&gt; tail, A head)
    {
        this.tail = tail;
        this.head = head;
    }

    public R Apply&lt;R&gt;(StreamFunction&lt;A, R&gt; tailFunction)
    {
        return tail.Apply(new ConsFunction&lt;A, R&gt;(tailFunction, head));
    }
}

public static Stream&lt;A&gt; Cons&lt;A&gt;(this Stream&lt;A&gt; s, A a)
{
    return new ConsStream&lt;A&gt;(s, a);
}</code></pre>
<p>Here, the Either class is used to represent sum types. It has two constructors and a generic method used to destruct its values:</p>
<pre><code>class Either&lt;A, B&gt;
{
    private bool flag;
    private A a;
    private B b;

    private Either() { }

    public static Either&lt;A, B&gt; inl(A value)
    {
        return new Either&lt;A, B&gt;
        {
            flag = true,
            a = value
        };
    }

    public static Either&lt;A, B&gt; inr(B value)
    {
        return new Either&lt;A, B&gt;
        {
            flag = false,
            b = value
        };
    }

    public T Case&lt;T&gt;(Func&lt;A, T&gt; aFunc, Func&lt;B, T&gt; bFunc)
    {
        return flag ? aFunc(a) : bFunc(b);
    }
}</code></pre>
<p>To take an element from the head of a stream, we can use the same generator function, but shift the seed value by one iteration:</p>
<pre><code>class NextStream&lt;A, T&gt; : Stream&lt;A&gt;
{
    private Stream&lt;A&gt; s;
    private StreamF&lt;A, T&gt; n;

    public NextStream(Stream&lt;A&gt; s, StreamF&lt;A, T&gt; n)
    {
        this.s = s;
        this.n = n;
    }

    public R Apply&lt;R&gt;(StreamFunction&lt;A, R&gt; f)
    {
        return f.Apply&lt;T&gt;(new StreamF&lt;A, T&gt;
        {
            Seed = n.Generator(n.Seed).Item1,
            Generator = n.Generator
        });
    }
}

class NextFunction&lt;A&gt; : StreamFunction&lt;A, Tuple&lt;A, Stream&lt;A&gt;&gt;&gt;
{
    private Stream&lt;A&gt; s;

    public NextFunction(Stream&lt;A&gt; s)
    {
        this.s = s;
    }

    public Tuple&lt;A, Stream&lt;A&gt;&gt; Apply&lt;T&gt;(StreamF&lt;A, T&gt; n)
    {
        return Tuple.Create&lt;A, Stream&lt;A&gt;&gt;(n.Generator(n.Seed).Item2,
            new NextStream&lt;A, T&gt;(s, n));
    }
}

public static Tuple&lt;A, Stream&lt;A&gt;&gt; Next&lt;A&gt;(this Stream&lt;A&gt; s)
{
    return s.Apply&lt;Tuple&lt;A, Stream&lt;A&gt;&gt;&gt;(new NextFunction&lt;A&gt;(s));
}</code></pre>
<p>Next time I plan to give a treatment of another greatest fixed point type - the conatural numbers - and their arithmetic.</p>

            <small>Built using <a href="http://jaspervdj.be/hakyll/">Hakyll</a></small>
        </div>
    </body>
</html>
