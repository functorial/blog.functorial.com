<!DOCTYPE HTML>
<html><head><title>Functorial Blog - The Visitor Pattern and Pattern Matching</title><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,300|Roboto:400,700|Roboto+Condensed:400,700"><link rel="stylesheet" type="text/css" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"><link rel="stylesheet" type="text/css" href="../assets/default.css"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="text/javascript" src="../assets/gaq.js"></script></head><body><div id="container"><h1 class="text-center">Functorial Blog</h1><p class="lead text-center">A blog about functional programming</p><p class="text-center"><a href="../index.html">Home</a></p></div><section class="dark"><div class="container"><h2>The Visitor Pattern and Pattern Matching</h2><p><small>by Phil Freeman on 2013/10/02</small></p><p>For many developers using Object Oriented programming languages, the Visitor Pattern is one of the first design patterns to provide a major roadblock in terms of understanding. It doesn&#39;t help that the typical examples are not particularly enlightening, but in my experience, it can be very difficult to explain to a beginner what is going on and why the design pattern is useful, especially with all of the syntactic noise that comes with a language like Java or C#.</p>
<p>I find it much easier to explain the visitor pattern by taking a detour through pattern matching, which can provide useful motivating examples.</p>
<h2>Motivating Example</h2>
<p>Suppose we want to write a method which calculates payroll for different types of employees. We&#39;re given the following business requirement: all employees are of one of two types:</p>
<ol>
<li>Hourly employees</li>
<li>Salaried employees</li>
</ol>
<p>One way to model this in an Object Oriented language would be to create an abstract class called <code>Employee</code> with three concrete subclasses <code>HourlyEmployee</code>, <code>SalariedEmployee</code>. <code>Employee</code> would be defined as an interface with a method for calculating the employee&#39;s monthly pay, and each employee class would be responsible for implementing it.</p>
<p>It might look something like this:</p>
<pre><code>public interface Employee {

    double calculatePay();
}

public class HourlyEmployee implements Employee {

    public double hourlyRate;
    public double hoursWorked;

    public double calculatePay() {
        return hoursWorked * hourlyRate;
    }
}

public class SalariedEmployee implements Employee {

    public double salary;

    public double calculatePay() {
        return salary / 12;
    }
}
</code></pre>
<h2>The Problem</h2>
<p>You complete the assignment and the code is deployed. It works so well that other developers want to make use of your code as a library in their own work.</p>
<p>Now suppose another business requirement is given: the number of paid vacation hours will be determined by the employee type; hourly employees will be given paid time off depending on the number of hours worked, salaried employees will be given a fixed amount of time off, etc.</p>
<p>Now the problem with the original approach rears its head. The developer responsible for this change should use your code as a library, and will not have access to the original code or the means to modify it. Here&#39;s the issue:</p>
<p><em>Subclass polymorphism easily allows the addition of new types of object, but does not easily allow the addition of new methods</em></p>
<p>This is the problem that the Visitor Pattern solves.</p>
<p><em>The Visitor Pattern easily allows the addition of new methods, but does not easily allow the addition of new types of object</em></p>
<p>We know that the types of employees are not likely to change, but we would like to add new methods to the Employee type, so it seems as if the Visitor pattern would be more appropriate.</p>
<p>When deciding if subclass inheritance is the correct solution for a problem, as yourself <em>&quot;would I prefer the consumers of my API to be able to add new subclasses, or new operations more easily?&quot;</em></p>
<h2>A Non-Solution using Reflection</h2>
<p>One anti-pattern which I sometimes see is to solve this problem by using reflection. In C#, the proposed solution might look something like this:</p>
<pre><code>public int computeVacationHours(Employee employee) {
    if (employee is HourlyEmployee) {
        HourlyExployee hourlyEmployee = (HourlyEmployee) employee;
        return ...
    } else if (employee is SalariedEmployee) {
        SalariedEmployee salariedEmployee = (SalariedEmployee) employee;
        return ...
    } else {
        throw new ArgumentException(&quot;Unknown employee type!&quot;);
    }
}
</code></pre>
<p>But we can do better. It would be nice if we didn&#39;t have to throw an exception in the final line. What we would really like is to statically check that all cases have been handled. If we could somehow prevent additional subclasses of <code>Employee</code> from being defined elsewhere, we wouldn&#39;t need to throw an exception. This problem can be solved using the visitor pattern.</p>
<h2>Solution Using Pattern Matching</h2>
<p>When I am trying to explain the purpose and implementation of the visitor pattern to another developer, I like to show them how I would solve the problem in a language with pattern matching. I then attempt to sell them the Visitor Pattern as the OOP-ification of pattern matching.</p>
<p>In Haskell, I would define the type of employees as follows:</p>
<pre class="{.haskell}"><code>data Employee 
  = HourlyEmployee { hourlyRate :: Double, hoursWorked :: Double }
  | SalariedEmployee { salary :: Double }
</code></pre>
<p>Hopefully, this is self-explanatory, but in case it isn&#39;t: reading the vertical bar as &quot;or&quot;, and the double colon as &quot;of type&quot;, this would read as &quot;An <code>Employee</code> is either an <code>HourlyEmployee</code> with an <code>hourlyRate</code> of type <code>Double</code>, or a <code>SalariedEmployee</code> with a salary of type <code>Double</code>.</p>
<p>Note that an <code>Employee</code> is either hourly or salaried, but never both, and an <code>Employee</code> constructed with the <code>SalariedEmployee</code> does not have an <code>hourlyRate</code>, for example.</p>
<p>With that, the original pay rate calculation, using pattern matching, would look like this:</p>
<pre class="{.haskell}"><code>calculatePay :: Employee -&gt; Double
calculatePay (HourlyEmployee hourlyRate hoursWorked) = hourlyRate * hoursWorked
calculatePay (SalariedEmployee salary) = salary / 12.0
</code></pre>
<p>Notice how the code is structured: it is expressed as a series of cases, each of which matches its input data using a specific pattern. The pattern binds some variables such as <code>hoursWorked</code>, which can then be used in the remainder of the computation, on the right hand side of the equals sign.</p>
<h2>Solution Using the Visitor Pattern</h2>
<p>If the visitor pattern is just the &quot;OOP-ification of pattern matching&quot;, then we should be able to derive it by attempting to translate the previous code into an object oriented language. I&#39;ll work in C#.</p>
<p>First, we encapsulate a computation which works by case analysis using an interface:</p>
<pre><code>public interface EmployeeCaseAnalysis&lt;Result&gt; {

    Result matchHourlyEmployee(double hourlyRate, double hoursWorked);
    
    Result matchSalariedEmployee(double salary);
}
</code></pre>
<p>An implementation of EmployeeCaseAnalysis<Result> needs to provide two methods: one calculates the result for an hourly employee, and the other calculates the result for a salaried employee.</p>
<p>The <code>Result</code> type parameter here is used to indicate the type of the result of the computation. More commonly, you will see a version of this class with no type parameter, which would be used when simply performing an action on the data, not transforming it.</p>
<pre><code>public interface EmployeeCaseAnalysis {

    void matchHourlyEmployee(double hourlyRate, double hoursWorked);
    
    void matchSalariedEmployee(double salary);
}
</code></pre>
<p>Now, we define the <code>Employee</code> interface. What is an <code>Employee</code>? Well, given any computation by case analysis, we want to be able to perform it and get a result. Here is the result:</p>
<pre><code>public interface Employee {

    void performCaseAnalysis(EmployeeCaseAnalysis caseAnalysis);
    
    Result performCaseAnalysis&lt;Result&gt;(EmployeeCaseAnalysis&lt;Result&gt; caseAnalysis);
}
</code></pre>
<p>A concrete class of <code>Employee</code> must provide a way to perform a case analysis with no result, or a case analysis with a result, no matter what its result type.</p>
<p>In fact, there are only two sensible ways to implement this specification: we can either call the <code>matchHourlyEmployee</code> method on the provided <code>EmployeeCaseAnalysis</code> object, if we have an <code>hourlyRate</code> and a number of <code>hoursWorked</code>, or we can call the <code>matchSalariedEmployee</code> method if we have a <code>salary</code>.</p>
<p>Let&#39;s call these two implementations <code>HourlyEmployee</code> and <code>SalariedEmployee</code>:</p>
<pre><code>public class HourlyEmployee implements Employee {

    public double hourlyRate;
    public double hoursWorked;

    public void performCaseAnalysis(EmployeeCaseAnalysis caseAnalysis) {
        caseAnalysis.matchHourlyEmployee(hourlyRate, hoursWorked);
    }

    public Result performCaseAnalysis&lt;Result&gt;(EmployeeCaseAnalysis&lt;Result&gt; caseAnalysis) {
        return caseAnalysis.matchHourlyEmployee(hourlyRate, hoursWorked);
    }
}

public class SalariedEmployee implements Employee {

    public double salary;

    public void performCaseAnalysis(EmployeeCaseAnalysis caseAnalysis) {
        caseAnalysis.matchSalariedEmployee(salary);
    }

    public Result performCaseAnalysis&lt;Result&gt;(EmployeeCaseAnalysis&lt;Result&gt; caseAnalysis) {
        return caseAnalysis.matchSalariedEmployee(salary);
    }
}

After some renaming, the code above looks just like code implemented using the visitor pattern. What I have called `EmployeeCaseAnalysis` might be renamed to `EmployeeVisitor`, and the `performCaseAnalysis` methods would most likely be renamed to `accept`. Here is the full version after the renamings:

</code></pre>
<p>public interface Employee {</p>
<pre><code>void accept(EmployeeVisitor visitor);

Result accept&lt;Result&gt;(EmployeeVisitor&lt;Result&gt; visitor);
</code></pre>
<p>}</p>
<p>public interface EmployeeVisitor {</p>
<pre><code>void visitHourlyEmployee(double hourlyRate);

void visitSalariedEmployee(double salary);
</code></pre>
<p>}</p>
<p>public interface EmployeeVisitor<Result> {</p>
<pre><code>Result visitHourlyEmployee(double hourlyRate);

Result visitSalariedEmployee(double salary);
</code></pre>
<p>}</p>
<p>public class HourlyEmployee implements Employee {</p>
<pre><code>public int hourlyRate;
public int hoursWorked;

public void accept(EmployeeVisitor visitor) {
    visitor.visitHourlyEmployee(hourlyRate, hoursWorked);
}

public Result accept&lt;Result&gt;(EmployeeVisitor&lt;Result&gt; visitor) {
    return visitor.visitHourlyEmployee(hourlyRate, hoursWorked);
}
</code></pre>
<p>}</p>
<p>public class SalariedEmployee implements Employee {</p>
<pre><code>public int salary;

public void accept(EmployeeVisitor visitor) {
    visitor.visitSalariedEmployee(salary);
}

public Result accept&lt;Result&gt;(EmployeeVisitor&lt;Result&gt; visitor) {
    return visitor.visitSalariedEmployee(salary);
}
</code></pre>
<p>}</p>
<p>It is also common to pass along the entire subclass of <code>Employee</code> to the <code>visitX</code> methods in <code>EmployeeVisitor</code>.</p>
<pre><code>public interface EmployeeVisitor {

    void visitHourlyEmployee(HourlyEmployee employee);
    
    void visitSalariedEmployee(SalariedEmployee employee);
}
</code></pre>
<p>But I will skip that here.</p>
<p>It is now possible to implement our original payroll computation as a subclass of <code>EmployeeVisitor</code>:</p>
<pre><code>public class PayrollCalulator implements EmployeeVisitor&lt;Double&gt; {

    public double visitHourlyEmployee(double hourlyRate, double hoursWorked) {
        return hourlyRate * hoursWorked;
    }
    
    public double visitSalariedEmployee(double salary) {
        return salary / 12.0;
    }
}
</code></pre>
<p>However, now our coworker can implement the computation of the number of vacation hours without modifying the original code!</p>
<pre><code>public class VacationCalculator implements EmployeeVisitor&lt;Integer&gt; {
   
    public int maxVacationHours;
    public int vacationHoursAccruedPerHourWorked;

    public int visitHourlyEmployee(double hourlyRate, double hoursWorked) {
        return Math.min(maxVacationHours, 
            Math.floor(hoursWorked / vacationHoursAccruedPerHourWorked));
    }
    
    public int visitSalariedEmployee(double salary) {
        return maxVacationHours;
    }
}
</code></pre>
<h2>A Recipe for Visitors</h2>
<p>That is the essence of the visitor pattern. We can summarise what we did in a number of bullet points which can be executed any time we&#39;d like to be able to perform abstract case analyses in an object oriented language.</p>
<p>Suppose we&#39;d like to perform case analysis on our new data type <code>Foo</code>:</p>
<ol>
<li>Add an interface called <code>FooVisitor</code>.</li>
<li>Add a void interface method to <code>FooVisitor</code> for each possible case in a case analysis, whose method arguments provide the additional data which is available in that case.</li>
<li>Optionally repeat steps 1 and 2 for a generic interface <code>FooVisitor&lt;Result&gt;</code>, in which all interface methods return a result of type <code>Result</code>.</li>
<li>Add an interface called <code>Foo</code>.</li>
<li>Add a void interface method <code>visit</code> to <code>Foo</code> which takes a <code>FooVisitor</code>.</li>
<li>Optionally add an interface method <code>visit</code> to <code>Foo</code> which takes a <code>FooVisitor&lt;Result&gt;</code> and returns a <code>Result</code>.</li>
<li>For each case, add a class implementing <code>Foo</code>, whose implementations of <code>visit</code> call the appropriate method on <code>FooVisitor</code>.</li>
</ol>
<p>It&#39;s a lot of boilerplate (which can be automated), but which gives us the flexibility to define new methods without modifying the original code.</p>
<h2>A Brief Type-Theoretic Detour</h2>
<p>You may wish to skip this section as it is not really necessary for understanding the visitor pattern, but I have included it since it may be helpful.</p>
<p>A simple example of a type which supports case analysis in Haskell is the <code>Either</code> data type, defined as follows:</p>
<pre class="{.haskell}"><code>data Either a b = Left a | Right b
</code></pre>
<p><code>Either</code> is what is known as a &quot;sum type&quot;, because it corresponds to addition at the type level.</p>
<p>A value of type <code>Either a b</code> is <em>either</em> constructed using <code>Left</code>, in which case it contains a value of type <code>a</code>, or with <code>Right</code>, in which case it contains a value of type <code>b</code>. A value of type <code>Either a b</code> contains <em>either</em> an <code>a</code> or a <code>b</code>, but not both.</p>
<p>We cannot immediately define the type <code>Either</code> in C#, since its type system doesn&#39;t support sum types. However, <code>Either</code> is isomorphic to a data type which is constructed only using functions, rank-2 polymorphism and records, both of which are available in C#, so it is possible to emulate <code>Either</code> in C# using those features.</p>
<p>Define the following data types</p>
<pre class="{.haskell}"><code>data EitherVisitor a b result = EitherVisitor { visitLeft :: a -&gt; result, visitRight :: b -&gt; result }

data Either&#39; a b = Either&#39; { acceptVisitor :: forall result. EitherVisitor a b result -&gt; result }
</code></pre>
<p>This code requires the <code>PolymorphicComponents</code> GHC extension.</p>
<p>The isomorphism between <code>Either</code> and <code>Either&#39;</code> can be witnessed by two functions:</p>
<pre class="{.haskell}"><code>forward :: Either a b -&gt; Either&#39; a b
forward (Left a) = Either&#39; $ flip visitLeft a
forward (Right a) = Either&#39; $ flip visitRight a

back :: Either&#39; a b -&gt; Either a b
back = acceptVisitor (EitherVisitor Left Right)
</code></pre>
<p>One can verify that these functions are indeed inverse to one another.</p>
<p>It is this isomorphism that ensures that the visitor pattern is a sound embedding of sum types into C# using only functions, generics and records. Since the types are isomorphic, we can be sure (assuming we don&#39;t do anything too subversive) that the typechecker will verify totality in our case analyses.</p>
<h2>Extending the Visitor Pattern</h2>
<p>The idea behind the visitor pattern can be combined with other features of languages like C# to create new patterns and enable new forms of abstraction. Here are some ideas:</p>
<ol>
<li>Use generic functions to emulate <em>existential types</em>.</li>
<li>Use generic type parameters to emulate <em>generalized algebraic data types</em>.</li>
</ol>
<p>I will leave these as extended exercises for the interested reader, but details can be found in some of my previous posts.</p>
<h2>The Expression Problem and Type Classes</h2>
<p>We have seen that the visitor pattern is useful when we have a fixed set of subclasses and would like to extend the set of operations on those subclasses. This is in contrast to subclass polymorphism which allows the addition of new subclasses for a fixed set of operations.</p>
<p>This begs the question: can we have the benefits of both? That is, can we write an abstraction which easily allows the definition of new subclasses, and new operations, without modification to the original code, and with support from the compiler.</p>
<p>This problem is called the Expression Problem and has been the subject of a great deal of research. In Haskell, the problem is solved using <em>type classes</em>, also known in other languages as <em>traits</em>. New &quot;subclasses&quot; can be defined by adding new data types and writing associated <em>type class instances</em>, and new operations can be defined by writing new <em>type classes</em> and retroactively providing instances for all existing data types.</p>
<p>For example, we might have two different data types for our two employee types in one module:</p>
<pre class="{.haskell}"><code>module Employee.Types

data HourlyEmployee = HourlyEmployee { hourlyRate :: Double, hoursWorked :: Double }

data SalariedEmployee = SalariedEmployee { salary :: Double }
</code></pre>
<p>And we could define a type class which represents the operation of computing monthly pay, in a second module:</p>
<pre class="{.haskell}"><code>module Employee.Payroll

class Payable employee where
    pay :: employee -&gt; Double
</code></pre>
<p>We can define type class instances for our existing employee types:</p>
<pre class="{.haskell}"><code>instance Payable HourlyEmployee where
    pay (HourlyEmployee hourlyRate hoursWorked) = hourlyRate * hoursWorked
    
instance Payable SalariedEmployee where
    pay (SalariedEmployee salary) = salary / 12.0
</code></pre>
<p>Now when a coworker would like to calculate paid vacation allowance, they can do so in another module by defining another type class and associated instances:</p>
<pre class="{.haskell}"><code>maxTimeOff :: Double
hoursOffPerHourWorked :: Double

class Vacation employee where
    timeOff :: employee -&gt; Int
    
instance Vacation HourlyEmployee where
    timeOff (HourlyEmployee _ hoursWorked) = min maxTimeOff (hoursWorked / hoursOffPerHourWorked)
    
instance Vacation SalariedEmployee where
    timeOff (SalariedEmployee _) = maxTimeOff
</code></pre>
<p>Now, despite their previous advice, management hands down a third business requirement that there will be a new employee type, who is to be paid a lump sum on completion of the allocated work, and who receives no paid vacation:</p>
<pre class="{.haskell}"><code>module Employee.Contract

data ContractEmployee = ContractEmployee { workCost :: Double, wasWorkCompletedThisMonth :: Bool }

instance Payable ContractEmployee where
    pay (ContractEmployee _ False) = 0.0
    pay (ContractEmployee workCost True) = workCost

instance Vacation ContractEmployee where
    timeOff (ContractEmployee _ _) = 0
</code></pre>
<p>This time, an employee was able to implement a new data type supporting existing operations by implementing existing type classes, without the need to modify any existing code.</p>
<p>Type classes allow Haskell developers to do more while writing less code. They allow a form of ad-hoc polymorphism and enable a degree of separation which is not possible in other languages.</p>
</div></section><div class="container"><p class="text-center text-muted"><small>Copyright Phil Freeman 2010-2015</small></p></div></body></html>