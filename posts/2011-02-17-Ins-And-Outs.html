<!DOCTYPE html>

<html>
    <head>
        <title>functorial.com - The Ins and Outs of Fixed Point Types</title>
        <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Lato:300,400,700"></link>
        <link rel="stylesheet" type="text/css" href="../css/default.css"></link>

        <script type="text/x-mathjax-config"> 
            MathJax.Hub.Config({
                config: ["MMLorHTML.js"],
                jax: ["input/TeX"],
                extensions: ["tex2jax.js"],
                TeX: { 
                    extensions: ["AMSmath.js", "AMSsymbols.js", "noErrors.js","noUndefined.js"] 
                },
                tex2jax: {
                    inlineMath: [['$','$'], ['\\(','\\)']]
                }
            }); 
        </script> 
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script> 

        <script type="text/javascript">
        
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-33896432-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        
        </script>
    </head>
    <body>
        <div id="header">
            <div class="centered" style="padding: 20px;">
                <h1><a href="../index.html" style="text-decoration: none; color: white;">functorial</a></h1>

                <p>Type Theory and Programming Languages Blog</p>
            </div>
    
            <div id="splitter"></div>
        </div>
    
        <div class="centered" style="padding: 20px;">
            <div id="navigation">
                <a href="../index.html">Home</a>
                <a href="../feed.xml">RSS Feed</a>
            </div>

            <h2>The Ins and Outs of Fixed Point Types</h2>

<p><small>by Phil Freeman on 2011/02/17</small></p>

<hr></hr>

<p>The purpose of this note is to derive the \(F\)-(co-)algebra structures on the least and greatest fixed points of \(F\) expressed in terms of universal and existential types. The method also extends to mutually recursive types by virtue of the fact that these types are the fixed points of functors on the power category \(\mathbb{C}^n\) for some \(n\), as explained in my last post.</p>
<h2 id="least-fixed-points">Least Fixed Points</h2>
<p>We defined the least fixed point of \(F\) by identifying an inhabitant with its fold function <code>cata</code>:</p>
<p>\(\mu F = \forall T. (F T \rightarrow T) \rightarrow T\)</p>
<p>We are also given a mapping on arrows:</p>
<p>\(\operatorname{fmap} :: \forall S T. (S \rightarrow T) \rightarrow FS \rightarrow FT\)</p>
<p>The goal is to define an algebra structure and a coalgebra structure on this type:</p>
<p>\(\begin{array}{ccc} \operatorname{in} &amp; :: &amp; \mu F \rightarrow F \mu F\\ \operatorname{out} &amp; :: &amp; F \mu F \rightarrow \mu F \end{array}\)</p>
<p>To define the algebra structure <code>out</code>, we use <code>fmap</code> to lift <code>cata</code> up one level in the structure:</p>
<blockquote>
<p>out x = { \T. \seed. seed (fmap (\y. cata[T] y seed) x) }</p>
</blockquote>
<p>To define the inverse <code>in</code>, observe that since \(\operatorname{out} \circ \operatorname{in} = \operatorname{id}\), we have</p>
<blockquote>
<p>in = fmap out . fmap in . in = cata fmap out</p>
</blockquote>
<p>by the universal property of <code>cata</code>.</p>
<h2 id="greatest-fixed-points">Greatest Fixed Points</h2>
<p>The case of greatest fixed points is exactly dual. We defined the greatest fixed point as</p>
<p>\(\begin{array}{ccc} \nu F &amp; = &amp; \exists T. T \times (T \rightarrow F T) \\ &amp; = &amp; \forall R. (\forall T. T \rightarrow (T \rightarrow FT) \rightarrow R) \rightarrow R \end{array}\)</p>
<p>Here we have constructed \(\nu F\) by identifying an inhabitant with its unfold function <code>ana</code>:</p>
<p>\(\operatorname{ana} :: \forall T. T \rightarrow (T \rightarrow FT) \rightarrow \nu F\)</p>
<p>Again we want to define algebra and coalgebra structures:</p>
<p>\(\begin{array}{ccc} \operatorname{in} &amp; :: &amp; \nu F \rightarrow F \nu F\\ \operatorname{out} &amp; :: &amp; F \nu F \rightarrow \nu F \end{array}\)</p>
<p>This time we will start with the coalgebra structure. The only way we can get something of type \(F \nu F\) is to unpack the existential type:</p>
<blockquote>
<p>in x = let x = (T, t, f) in fmap (\y. ana y f) (f t)</p>
</blockquote>
<p>To define the map <code>out</code>, we reason as follows:</p>
<blockquote>
<p>out = out . fmap out . fmap in = ana fmap in</p>
</blockquote>
<p>by the universal property of <code>ana</code>.</p>
<h2 id="mutually-recursive-types">Mutually Recursive Types</h2>
<p>The methods above continue to work in the power category \(\mathbb{C}^n\) and so by replacing functors and arrows in the power category with tuples of functors and tuples of arrows in the category \(\mathbb{C}\), we can express mututally recursive types and functions in the category \(\mathbb{C}\).</p>
<p>The second example below shows how this can be done for the case of the (co-)even and (co-)odd natural numbers defined as a mutually recursive pair of types.</p>
<p>Using just the methods <code>cata</code>, <code>ana</code>, <code>in</code> and <code>out</code> we can build a large collection of library methods manipulating odd/even (co-)naturals. For example, addition and multiplication of even numbers can be defined by</p>
<blockquote>
<p>add e1 e2 = cata e1 <const e2, out1> out2</p>
<p>mult e1 e2 = cata e1 <zero, add (const e2 inr)> add e2</p>
</blockquote>
<p>where <code>zero = out1</code> inl and <code>out1</code> and <code>out2</code> denote the two parts of the morphism out in the category \(\mathbb{C}^2\).</p>
<p>Alternatively, in C#, using the definitions given in the example code below, we could write</p>
<pre><code>Func&lt;Even, Even, Even&gt; add = (e1, e2) =&gt; e1.Cata&lt;Even, Odd&gt;(
    f1 =&gt; f1.IsZero
        ? e2
        : Nat.Out1(f1),
    Nat.Out2);

Func&lt;Even, Even, Even&gt; mult = (e1, e2) =&gt; e1.Cata&lt;Even, Even&gt;(
    f1 =&gt; f1.IsZero
        ? zero
        : add(e2, f1.Pred),
    f2 =&gt; add(e2, f2.Pred));</code></pre>

<hr></hr>

<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'functorial'; 

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a>
    


            <small>Built using <a href="http://jaspervdj.be/hakyll/">Hakyll</a></small>
        </div>
    </body>
</html>
