<!DOCTYPE HTML>
<html><head><title>functorial.com - The Ins and Outs of Fixed Point Types</title><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Lato:300,400,700"><link rel="stylesheet" type="text/css" href="../css/default.css"><meta name="viewport" content="width=device-width, initial-scale=1.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
    config: ['MMLorHTML.js'],
    jax: ['input/TeX'],
    extensions: ['tex2jax.js'],
    TeX: {
        extensions: ['AMSmath.js', 'AMSsymbols.js', 'noErrors.js','noUndefined.js']
    },
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']]
    }
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-33896432-1']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script></head><body><div id="header"><div class="centered"><h1><a href="../index.html" style="text-decoration: none; color: white;">functorial</a></h1><p>Type Theory and Programming Languages Blog</p></div><div id="splitter"></div></div><div class="centered"><div id="navigation"><a href="../index.html">Home</a>&nbsp;<a href="../feed.xml">RSS Feed</a></div><h2>The Ins and Outs of Fixed Point Types</h2><p><small>by Phil Freeman on 2011/02/17</small></p><hr><p>The purpose of this note is to derive the <span class="math">\(F\)</span>-(co-)algebra structures on the least and greatest fixed points of <span class="math">\(F\)</span> expressed in terms of universal and existential types. The method also extends to mutually recursive types by virtue of the fact that these types are the fixed points of functors on the power category <span class="math">\(\mathbb{C}^n\)</span> for some <span class="math">\(n\)</span>, as explained in my last post.</p>
<h2 id="least-fixed-points">Least Fixed Points</h2>
<p>We defined the least fixed point of <span class="math">\(F\)</span> by identifying an inhabitant with its fold function <code>cata</code>:</p>
<p><span class="math">\(\mu F = \forall T. (F T \rightarrow T) \rightarrow T\)</span></p>
<p>We are also given a mapping on arrows:</p>
<p><span class="math">\(\operatorname{fmap} :: \forall S T. (S \rightarrow T) \rightarrow FS \rightarrow FT\)</span></p>
<p>The goal is to define an algebra structure and a coalgebra structure on this type:</p>
<p><span class="math">\(\begin{array}{ccc}   \operatorname{in}  &amp; :: &amp; \mu F   \rightarrow F \mu F\\   \operatorname{out} &amp; :: &amp; F \mu F \rightarrow   \mu F \end{array}\)</span></p>
<p>To define the algebra structure <code>out</code>, we use <code>fmap</code> to lift <code>cata</code> up one level in the structure:</p>
<blockquote>
<p>out x = { \T. \seed. seed (fmap (\y. cata[T] y seed) x) }</p>
</blockquote>
<p>To define the inverse <code>in</code>, observe that since <span class="math">\(\operatorname{out} \circ \operatorname{in} = \operatorname{id}\)</span>, we have</p>
<blockquote>
<p>in = fmap out . fmap in . in = cata fmap out</p>
</blockquote>
<p>by the universal property of <code>cata</code>.</p>
<h2 id="greatest-fixed-points">Greatest Fixed Points</h2>
<p>The case of greatest fixed points is exactly dual. We defined the greatest fixed point as</p>
<p><span class="math">\(\begin{array}{ccc}   \nu F &amp; = &amp; \exists T. T \times (T \rightarrow F T) \\         &amp; = &amp; \forall R. (\forall T. T \rightarrow (T \rightarrow FT) \rightarrow R) \rightarrow R \end{array}\)</span></p>
<p>Here we have constructed <span class="math">\(\nu F\)</span> by identifying an inhabitant with its unfold function <code>ana</code>:</p>
<p><span class="math">\(\operatorname{ana} :: \forall T. T \rightarrow (T \rightarrow FT) \rightarrow \nu F\)</span></p>
<p>Again we want to define algebra and coalgebra structures:</p>
<p><span class="math">\(\begin{array}{ccc}   \operatorname{in}  &amp; :: &amp; \nu F   \rightarrow F \nu F\\   \operatorname{out} &amp; :: &amp; F \nu F \rightarrow   \nu F \end{array}\)</span></p>
<p>This time we will start with the coalgebra structure. The only way we can get something of type <span class="math">\(F \nu F\)</span> is to unpack the existential type:</p>
<blockquote>
<p>in x = let x = (T, t, f) in fmap (\y. ana y f) (f t)</p>
</blockquote>
<p>To define the map <code>out</code>, we reason as follows:</p>
<blockquote>
<p>out = out . fmap out . fmap in = ana fmap in</p>
</blockquote>
<p>by the universal property of <code>ana</code>.</p>
<h2 id="mutually-recursive-types">Mutually Recursive Types</h2>
<p>The methods above continue to work in the power category <span class="math">\(\mathbb{C}^n\)</span> and so by replacing functors and arrows in the power category with tuples of functors and tuples of arrows in the category <span class="math">\(\mathbb{C}\)</span>, we can express mututally recursive types and functions in the category <span class="math">\(\mathbb{C}\)</span>.</p>
<p>The second example below shows how this can be done for the case of the (co-)even and (co-)odd natural numbers defined as a mutually recursive pair of types.</p>
<p>Using just the methods <code>cata</code>, <code>ana</code>, <code>in</code> and <code>out</code> we can build a large collection of library methods manipulating odd/even (co-)naturals. For example, addition and multiplication of even numbers can be defined by</p>
<blockquote>
<p>add e1 e2 = cata e1 <const e2, out1> out2</p>
<p>mult e1 e2 = cata e1 <zero, add (const e2 inr)> add e2</p>
</blockquote>
<p>where <code>zero = out1</code> inl and <code>out1</code> and <code>out2</code> denote the two parts of the morphism out in the category <span class="math">\(\mathbb{C}^2\)</span>.</p>
<p>Alternatively, in C#, using the definitions given in the example code below, we could write</p>
<pre><code>Func&lt;Even, Even, Even&gt; add = (e1, e2) =&gt; e1.Cata&lt;Even, Odd&gt;(
    f1 =&gt; f1.IsZero
        ? e2
        : Nat.Out1(f1),
    Nat.Out2);

Func&lt;Even, Even, Even&gt; mult = (e1, e2) =&gt; e1.Cata&lt;Even, Even&gt;(
    f1 =&gt; f1.IsZero
        ? zero
        : add(e2, f1.Pred),
    f2 =&gt; add(e2, f2.Pred));</code></pre>
<hr><div id="disqus_thread"><script type="text/javascript">var disqus_shortname = 'functorial';
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></body></html>