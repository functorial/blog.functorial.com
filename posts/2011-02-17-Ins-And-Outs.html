<!DOCTYPE HTML>
<html><head><title>Functorial Blog - The Ins and Outs of Fixed Point Types</title><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,300|Roboto:400,700|Roboto+Condensed:400,700"><link rel="stylesheet" type="text/css" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"><link rel="stylesheet" type="text/css" href="../assets/default.css"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="text/javascript" src="../assets/gaq.js"></script></head><body><div id="container"><h1 class="text-center">Functorial Blog</h1><p class="lead text-center">A blog about functional programming</p><p class="text-center"><a href="../index.html">Home</a></p></div><section class="dark"><div class="container"><h2>The Ins and Outs of Fixed Point Types</h2><p><small>by Phil Freeman on 2011/02/17</small></p><p>The purpose of this note is to derive the $F$-(co-)algebra structures on the least and greatest fixed points of $F$ expressed in terms of universal and existential types. The method also extends to mutually recursive types by virtue of the fact that these types are the fixed points of functors on the power category $\mathbb{C}^n$ for some $n$, as explained in my last post.</p>
<h2>Least Fixed Points</h2>
<p>We defined the least fixed point of $F$ by identifying an inhabitant with its fold function <code>cata</code>:</p>
<p>$\mu F = \forall T. (F T \rightarrow T) \rightarrow T$</p>
<p>We are also given a mapping on arrows:</p>
<p>$\operatorname{fmap} :: \forall S T. (S \rightarrow T) \rightarrow FS \rightarrow FT$</p>
<p>The goal is to define an algebra structure and a coalgebra structure on this type:</p>
<p>$\begin{array}{ccc}
\operatorname{in} &amp; :: &amp; \mu F \rightarrow F \mu F\
\operatorname{out} &amp; :: &amp; F \mu F \rightarrow \mu F
\end{array}$</p>
<p>To define the algebra structure <code>out</code>, we use <code>fmap</code> to lift <code>cata</code> up one level in the structure:</p>
<blockquote>
<p>out x = { \T. \seed. seed (fmap (\y. cata[T] y seed) x) }</p>
</blockquote>
<p>To define the inverse <code>in</code>, observe that since $\operatorname{out} \circ \operatorname{in} = \operatorname{id}$, we have</p>
<blockquote>
<p>in = fmap out . fmap in . in = cata fmap out</p>
</blockquote>
<p>by the universal property of <code>cata</code>.</p>
<h2>Greatest Fixed Points</h2>
<p>The case of greatest fixed points is exactly dual. We defined the greatest fixed point as</p>
<p>$\begin{array}{ccc}
\nu F &amp; = &amp; \exists T. T \times (T \rightarrow F T) \
&amp; = &amp; \forall R. (\forall T. T \rightarrow (T \rightarrow FT) \rightarrow R) \rightarrow R
\end{array}$</p>
<p>Here we have constructed $\nu F$ by identifying an inhabitant with its unfold function <code>ana</code>:</p>
<p>$\operatorname{ana} :: \forall T. T \rightarrow (T \rightarrow FT) \rightarrow \nu F$</p>
<p>Again we want to define algebra and coalgebra structures:</p>
<p>$\begin{array}{ccc}
\operatorname{in} &amp; :: &amp; \nu F \rightarrow F \nu F\
\operatorname{out} &amp; :: &amp; F \nu F \rightarrow \nu F
\end{array}$</p>
<p>This time we will start with the coalgebra structure. The only way we can get something of type $F \nu F$ is to unpack the existential type:</p>
<blockquote>
<p>in x = let x = (T, t, f) in fmap (\y. ana y f) (f t)</p>
</blockquote>
<p>To define the map <code>out</code>, we reason as follows:</p>
<blockquote>
<p>out = out . fmap out . fmap in = ana fmap in</p>
</blockquote>
<p>by the universal property of <code>ana</code>.</p>
<h2>Mutually Recursive Types</h2>
<p>The methods above continue to work in the power category $\mathbb{C}^n$ and so by replacing functors and arrows in the power category with tuples of functors and tuples of arrows in the category $\mathbb{C}$, we can express mututally recursive types and functions in the category $\mathbb{C}$.</p>
<p>The second example below shows how this can be done for the case of the (co-)even and (co-)odd natural numbers defined as a mutually recursive pair of types.</p>
<p>Using just the methods <code>cata</code>, <code>ana</code>, <code>in</code> and <code>out</code> we can build a large collection of library methods manipulating odd/even (co-)naturals. For example, addition and multiplication of even numbers can be defined by</p>
<blockquote>
<p>add e1 e2 = cata e1 &lt;const e2, out1&gt; out2</p>
<p>mult e1 e2 = cata e1 &lt;zero, add (const e2 inr)&gt; add e2</p>
</blockquote>
<p>where <code>zero = out1</code> inl and <code>out1</code> and <code>out2</code> denote the two parts of the morphism out in the category $\mathbb{C}^2$.</p>
<p>Alternatively, in C#, using the definitions given in the example code below, we could write</p>
<pre><code>Func&lt;Even, Even, Even&gt; add = (e1, e2) =&gt; e1.Cata&lt;Even, Odd&gt;(
    f1 =&gt; f1.IsZero
        ? e2
        : Nat.Out1(f1),
    Nat.Out2);

Func&lt;Even, Even, Even&gt; mult = (e1, e2) =&gt; e1.Cata&lt;Even, Even&gt;(
    f1 =&gt; f1.IsZero
        ? zero
        : add(e2, f1.Pred),
    f2 =&gt; add(e2, f2.Pred));
</code></pre>
</div></section><div class="container"><p class="text-center text-muted"><small>Copyright Phil Freeman 2010-2015</small></p></div></body></html>