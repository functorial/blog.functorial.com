<html><head><title>functorial.com - Mutually Recursive Types and Functions</title><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Lato:300,400,700"><link rel="stylesheet" type="text/css" href="/css/default.css"><meta name="viewport" content="width=device-width, initial-scale=1.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
    config: ['MMLorHTML.js'],
    jax: ['input/TeX'],
    extensions: ['tex2jax.js'],
    TeX: {
        extensions: ['AMSmath.js', 'AMSsymbols.js', 'noErrors.js','noUndefined.js']
    },
    tex2jax: {
        inlineMath: [['$','$'], ['\(','\)']]
    }
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-33896432-1']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script></head><body><div id="header"><div class="centered"><h1><a href="/index.html" style="text-decoration: none; color: white;">functorial</a></h1><p>Type Theory and Programming Languages Blog</p></div><div id="splitter"></div></div><div class="centered"><div id="navigation"><a href="/index.html">Home</a>&nbsp;<a href="/feed.xml">RSS Feed</a></div><h2>Mutually Recursive Types and Functions</h2><p><small>by Phil Freeman on 2011/02/16</small></p><hr><p>The methods used in my previous posts (here and here) to encode least and greatest fixed points using universal and existential types can be extended to encode least and greatest fixed points of functors on product categories which correspond to mutually recursive types. Catamorphisms and anamorphisms for these types are mutually recursive functions.</p>
<h2 id="example">Example</h2>
<p>If <span class="math">C</span> is our usual category of types then we work over <span class="math">C<sup>2</sup></span>, the category whose objects are pairs of objects of <span class="math">C</span> and whose morphisms are pairs of morphisms of <span class="math">C</span> between the appropriate objects.</p>
<p>Consider the endofunctor on <span class="math">C<sup>2</sup></span> given by <span class="math"><em>F</em>(<em>X</em>, <em>Y</em>) = (1 + <em>Y</em>, <em>X</em>)</span></p>
<p>The least fixed point of this functor is a pair of types <span class="math">(Even, Odd)</span> such that</p>
<p><span class="math">$\begin{array}{ccc}   \text{Even} &amp; = &amp; 1 + \text{Odd} \\   \text{Odd}  &amp; = &amp; \text{Even} \end{array}$</span></p>
<p>We can interpret this pair of types as the even and odd natural numbers.</p>
<p>We can express the functor <span class="math"><em>F</em></span> as a pair of functors in the category of types <span class="math">C</span>:</p>
<pre><code>class F1&lt;X, Y&gt;
{
    public bool IsZero { get; set; }

    public Y Pred { get; set; }

    public F1() { IsZero = true; }

    public F1(Y pred)
    {
        IsZero = false;
        Pred = pred;
    }
}

class F2&lt;X, Y&gt;
{
    public X Pred { get; set; }

    public F2(X pred) { Pred = pred; }
}</code></pre>
<p>Now, using the encoding <span class="math"><em>μ</em><em>F</em> = ∀ <em>T</em>. (<em>F</em><em>T</em> → <em>T</em>) → <em>T</em></span> and the fact that an arrow in <span class="math">C<sup>2</sup></span> is just a pair of arrows in <span class="math">C</span>, we have the definition:</p>
<pre><code>interface Even
{
    X Cata&lt;X, Y&gt;(Func&lt;F1&lt;X, Y&gt;, X&gt; f1, Func&lt;F2&lt;X, Y&gt;, Y&gt; f2);
}

interface Odd
{
    Y Cata&lt;X, Y&gt;(Func&lt;F1&lt;X, Y&gt;, X&gt; f1, Func&lt;F2&lt;X, Y&gt;, Y&gt; f2);
}</code></pre>
<p>Similarly, using the encoding for greatest fixed points:</p>
<p><span class="math">$\begin{array}{ccc}   \nu F &amp; = &amp; \exists T. T \times (T \rightarrow F T) \\         &amp; = &amp; \forall R. (\forall T. T \rightarrow (T \rightarrow FT) \rightarrow R) \rightarrow R \end{array}$</span></p>
<p>we have the definitions</p>
<pre><code>interface CoEvenFunc&lt;R&gt;
{
    R Apply&lt;X, Y&gt;(X x, Func&lt;X, F1&lt;X, Y&gt;&gt; f1, Func&lt;Y, F2&lt;X, Y&gt;&gt; f2);
}

interface CoOddFunc&lt;R&gt;
{
    R Apply&lt;X, Y&gt;(Y y, Func&lt;X, F1&lt;X, Y&gt;&gt; f1, Func&lt;Y, F2&lt;X, Y&gt;&gt; f2);
}

interface CoEven
{
    R Apply&lt;R&gt;(CoEvenFunc&lt;R&gt; f);
}

interface CoOdd
{
    R Apply&lt;R&gt;(CoOddFunc&lt;R&gt; f);
}</code></pre>
<p>The type of coeven numbers looks like the type of even numbers with an additional value of infinity. Similarly, the coodd numbers have an additional infinite value, whose successor is the coeven infinite value and vice versa.</p>
<p>A catamorphism or anamorphism for these types makes the mutual recursion obvious:</p>
<pre><code>Func&lt;Even, int&gt; ToInt =
    e =&gt; e.Cata&lt;int, int&gt;(
        f1 =&gt; f1.IsZero
            ? 0
            : f1.Pred + 1,
        f2 =&gt; f2.Pred + 1);

Func&lt;int, CoEven&gt; FromInt =
    n =&gt; CoNat.Ana&lt;int, int&gt;(n,
        n1 =&gt; n1 == 0
            ? new F1&lt;int, int&gt;()
            : new F1&lt;int, int&gt;(n1 - 1),
        n2 =&gt; new F2&lt;int, int&gt;(n2 - 1));</code></pre>
<hr><div id="disqus_thread"><script type="text/javascript">var disqus_shortname = 'functorial';
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></body></html>