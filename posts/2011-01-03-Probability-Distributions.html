<!DOCTYPE html>

<html>
    <head>
        <title>functorial.com - LINQ to Probability Distributions</title>
        <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu+Mono"></link>
        <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Lato:300,400,700"></link>
        <link rel="stylesheet" type="text/css" href="../css/default.css"></link>

        <script type="text/x-mathjax-config"> 
            MathJax.Hub.Config({
                config: ["MMLorHTML.js"],
                jax: ["input/TeX"],
                extensions: ["tex2jax.js"],
                TeX: { 
                    extensions: ["AMSmath.js", "AMSsymbols.js", "noErrors.js","noUndefined.js"] 
                },
                tex2jax: {
                    inlineMath: [['$','$'], ['\\(','\\)']]
                }
            }); 
        </script> 
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script> 
    </head>
    <body>
        <div id="wrapper">
            <h1>LINQ to Probability Distributions</h1>

            <div id="navigation">
                <a href="../index.html">Home</a>
            </div>

            <p>Here is an example of an interesting monad which I have not seen expressed anywhere using LINQ's extension methods.</p>
<h2 id="probability-distributions">Probability Distributions</h2>
<p>Define a probability distribution with entries in type T as a list of outcomes with probabilities:</p>
<pre><code>public class Outcome&lt;T&gt;
{
    public T Value
    {
        get;
        set;
    }

    public double Probability
    {
        get;
        set;
    }

    public Outcome(T value, double probability)
    {
        Value = value;
        Probability = probability;
    }
}

public class Distribution&lt;T&gt;
{
    public IEnumerable&lt;Outcome&lt;T&gt;&gt; Outcomes
    {
        get;
        set;
    }

    public Distribution(IEnumerable&lt;Outcome&lt;T&gt;&gt; outcomes)
    {
        Outcomes = outcomes;
    }
}</code></pre>
<p>We can inject a value into the monad by returning a distribution which returns a single value with certainty:</p>
<pre><code>public static Distribution&lt;T&gt; Return&lt;T&gt;(T t)
{
    return new Distribution&lt;T&gt;(new Outcome&lt;T&gt;[] { new Outcome&lt;T&gt;(t, 1.0) });
}</code></pre>
<h2 id="extension-methods">Extension Methods</h2>
<p>Distributions are functorial: a function on outcomes lifts to a function on distributions:</p>
<pre><code>public static Distribution&lt;T&gt; Select&lt;S, T&gt;(this Distribution&lt;S&gt; d,
    Func&lt;S, T&gt; f)
{
    return new Distribution&lt;T&gt;(d.Outcomes.Select(p =&gt;
        new Outcome&lt;T&gt;(f(p.Value), p.Probability)));
}</code></pre>
<p>The monad's bind operation combines a distribution with a dependent distribution in the way one would expect by multiplying probabilities:</p>
<pre><code>public static Distribution&lt;T&gt; SelectMany&lt;S, T&gt;(this Distribution&lt;S&gt; d,
    Func&lt;S, Distribution&lt;T&gt;&gt; s)
{
    return new Distribution&lt;T&gt;(d.Outcomes.SelectMany(p =&gt;
        s(p.Value).Outcomes.Select(p1 =&gt;
            new Outcome&lt;T&gt;(p1.Value, p.Probability * p1.Probability))));
}</code></pre>
<p>Here we are simply applying the rule \(P(A \text{ and } B) = P(A | B) \times P(B)\).</p>
<p>Distributions also form a monad-with-zero - for every type T, there is an empty distribution with values in T:</p>
<pre><code>public static Distribution&lt;T&gt; Empty&lt;T&gt;()
{
    return new Distribution&lt;T&gt;(Enumerable.Empty&lt;Outcome&lt;T&gt;&gt;());
}</code></pre>
<p>Now, any monad-with-zero has a means of filtering out values according to a predicate:</p>
<pre><code>public static Distribution&lt;T&gt; Where&lt;T&gt;(this Distribution&lt;T&gt; d, Func&lt;T, bool&gt; p)
{
    return from possibility in d
           from oneOrZero in p(possibility) ? Return(possibility) : Empty&lt;T&gt;()
           select oneOrZero;
}</code></pre>
<p>With these methods, we have the means to calculate monad comprehensions, that is a way of combining, mapping and filtering values in the monad to form complicated distributions.</p>
<h2 id="calculating-with-distributions">Calculating With Distributions</h2>
<p>There are a number of methods that we can use to remove a wrapped value from the monad. For any distribution, we can find the sum of probabilities in a distribution. It is also useful to combine a filter with a sum of probabilities:</p>
<pre><code>public static double Probability&lt;T&gt;(this Distribution&lt;T&gt; d)
{
    return d.Outcomes.Sum(p =&gt; p.Probability);
}

public static double Probability&lt;T&gt;(this Distribution&lt;T&gt; d,
    Func&lt;T, bool&gt; predicate)
{
    return d.Where(predicate).Outcomes.Sum(p =&gt; p.Probability);
}</code></pre>
<p>For numerical distributions, we can find the mean and standard deviation:</p>
<pre><code>public static double Average(this Distribution&lt;double&gt; d)
{
    return d.Outcomes.Select(o =&gt; o.Value * o.Probability).Sum();
}

public static double Variance(this Distribution&lt;double&gt; d)
{
    var average = d.Average();
    return d.Select(o =&gt; (o - average) * (o - average)).Average();
}</code></pre>
<p>The Distribution of a Die-Roll</p>
<p>We can define the distribution of a single die-roll as follows:</p>
<pre><code>var fairDie = new Distribution&lt;int&gt;(new[]
{
    new Outcome&lt;int&gt;(1, 1.0 / 6.0),
    new Outcome&lt;int&gt;(2, 1.0 / 6.0),
    new Outcome&lt;int&gt;(3, 1.0 / 6.0),
    new Outcome&lt;int&gt;(4, 1.0 / 6.0),
    new Outcome&lt;int&gt;(5, 1.0 / 6.0),
    new Outcome&lt;int&gt;(6, 1.0 / 6.0)
});</code></pre>
<p>Our extension methods allow us to form the distribution of the sum of the rolls of two independent fair dice:</p>
<pre><code>var sum = from d1 in fairDie
          from d2 in fairDie
          select (double) d1 + d2;</code></pre>
<p>We can use our extension methods to find the probabilities of various events:</p>
<blockquote>
<p>Console.WriteLine(&quot;P(S = 7) = {0:.##}&quot;, sum.Probability(s =&gt; s == 7));</p>
<p>P(S = 7) = .17</p>
<p>Console.WriteLine(&quot;P(S Odd) = {0:.##}&quot;, sum.Probability(s =&gt; s % 2 &gt; 0));</p>
<p>P(S Odd) = .5</p>
<p>Console.WriteLine(&quot;Mean = {0:.##}&quot;, sum.Average());</p>
<p>Mean = 7</p>
<p>Console.WriteLine(&quot;Std. Dev. = {0:.##}&quot;, Math.Sqrt(sum.Variance()));</p>
<p>Std. Dev. = 2.42</p>
</blockquote>
<p>We can also model non-independent events - in the following game, the player gets to replace the fair die with a loaded die if a fair coin lands heads-up:</p>
<pre><code>var coinToss = new Distribution&lt;bool&gt; (new []
{
    new Outcome&lt;bool&gt;(true, 1.0 / 2.0),
    new Outcome&lt;bool&gt;(false, 1.0 / 2.0)
});

var loadedDie = new Distribution&lt;int&gt;(new[]
{
    new Outcome&lt;int&gt;(1, 1.0 / 10.0),
    new Outcome&lt;int&gt;(2, 1.0 / 10.0),
    new Outcome&lt;int&gt;(3, 1.0 / 10.0),
    new Outcome&lt;int&gt;(4, 1.0 / 10.0),
    new Outcome&lt;int&gt;(5, 1.0 / 10.0),
    new Outcome&lt;int&gt;(6, 1.0 / 2.0)
});

var roll = from heads in coinToss
           let die = heads ? loadedDie : fairDie
           from roll1 in die
           from roll2 in die
           select (double) roll1 + roll2;</code></pre>
<p>As one would expect, the player's expected sum is now higher:</p>
<blockquote>
<p>Console.WriteLine(&quot;Mean = {0:.##}&quot;, roll.Average());</p>
<p>Mean = 8</p>
</blockquote>
<h2 id="references">References</h2>
<p>[1] Probabilistic Functional Programming In Haskell (M. Erwig, S. Kollmansberger, 2006)</p>

            <small>Built using <a href="http://jaspervdj.be/hakyll/">Hakyll</a></small>
        </div>
    </body>
</html>
