<!DOCTYPE html>

<html>
    <head>
        <title>functorial.com - Least Fixed Points and Catamorphisms in C#</title>
        <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu+Mono"></link>
        <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Lato:300,400,700"></link>
        <link rel="stylesheet" type="text/css" href="../css/default.css"></link>

        <script type="text/x-mathjax-config"> 
            MathJax.Hub.Config({
                config: ["MMLorHTML.js"],
                jax: ["input/TeX"],
                extensions: ["tex2jax.js"],
                TeX: { 
                    extensions: ["AMSmath.js", "AMSsymbols.js", "noErrors.js","noUndefined.js"] 
                },
                tex2jax: {
                    inlineMath: [['$','$'], ['\\(','\\)']]
                }
            }); 
        </script> 
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script> 

        <script type="text/javascript">
        
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-33896432-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        
        </script>
    </head>
    <body>
        <div id="wrapper">
            <h1>Least Fixed Points and Catamorphisms in C#</h1>

            <div id="navigation">
                <a href="../index.html">Home</a>
                <a href="../feed.xml">RSS Feed</a>
            </div>

            <p>I've been trying to find a nice way to encode least fixed points in C# for a while. At first, I tried to define a functor interface. Unfortunately, due to C#'s lack of type constructor polymorphism, there isn't really a nice way to do this in a type-safe way. However, there is a nice way to encode least fixed points without using the functorial structure at all.</p>
<p>We use the isomorphism</p>
<blockquote>
<p>Mu F ~ forall X. (F X -&gt; X) -&gt; X</p>
</blockquote>
<p>The isomorphism is given by</p>
<blockquote>
<p>\x. \X. \f. cata f x</p>
</blockquote>
<p>where <code>cata f</code> denotes the catamorphism generated by <code>f</code>.</p>
<p>The inverse is given by</p>
<blockquote>
<p>\y. y in</p>
</blockquote>
<p>where <code>in :: F Mu F -&gt; Mu F</code> is the algebra morphism. Note that <code>cata in = id</code> implies that this is indeed an inverse.</p>
<p>Unfortunately, we can't capture the type constructor F as a first-class value in C#, again due to the lack of type constructor polymorphism.</p>
<p>For now, let's take the example of cons lists. We have</p>
<blockquote>
<p>List A = Mu (\X. 1 + A.X)</p>
</blockquote>
<p>Translating this into C#, we have</p>
<pre><code>struct ListF&lt;A, T&gt;
{
    public A a;
    public T t;
}

interface List&lt;A&gt;
{
    T Cata&lt;T&gt;(Func&lt;ListF&lt;A, T&gt;?, T&gt; generator);
}</code></pre>
<p>How can we use this? Well, we can define the empty list:</p>
<pre><code>class EmptyList&lt;A&gt; : List&lt;A&gt;
{
    public T Cata&lt;T&gt;(Func&lt;ListF&lt;A, T&gt;?, T&gt; generator)
    {
        return generator(null);
    }
}</code></pre>
<p>and a means of consing an element onto the front of an existing list:</p>
<pre><code>class Cons&lt;A&gt; : List&lt;A&gt;
{
    public A x;
    public List&lt;A&gt; xs;

    public Cons(A x, List&lt;A&gt; xs)
    {
        this.x = x;
        this.xs = xs;
    }

    public T Cata&lt;T&gt;(Func&lt;ListF&lt;A, T&gt;?, T&gt; generator)
    {
        return generator(new ListF&lt;A, T&gt;
        {
            a = x,
            t = xs.Cata(generator)
        });           
    }
} </code></pre>
<p>Finally we can turn a <code>List&lt;A&gt;</code> into an array <code>A[]</code>:</p>
<pre><code>public static T[] ToArray&lt;T&gt;(this List&lt;T&gt; list)
{
    return list.Cata&lt;T[]&gt;(x =&gt; x.HasValue
        ? new T[] {x.Value.a}.Concat(x.Value.t).ToArray()
        : new T[0]);
}</code></pre>
<p>Some extension methods can make the creation of lists easier:</p>
<pre><code>public static List&lt;T&gt; Empty&lt;T&gt;()
{
    return new EmptyList&lt;T&gt;();
}

public static List&lt;T&gt; Cons&lt;T&gt;(this List&lt;T&gt; list, T t)
{
    return new Cons&lt;T&gt;(t, list);
}</code></pre>
<p>Now we can manipulate lists in the ways you would expect:</p>
<blockquote>
<p>Empty<int>().Cons(1).Cons(2).Cons(3).ToArray() [3, 2, 1]</p>
</blockquote>
<p>We can also encode greatest fixed points using</p>
<blockquote>
<p>Nu F ~ Exists X. X * (X -&gt; FX)</p>
</blockquote>
<p>using the encoding of existentials which I described in my previous post, but that's a story for my next post.</p>

            <small>Built using <a href="http://jaspervdj.be/hakyll/">Hakyll</a></small>
        </div>
    </body>
</html>
