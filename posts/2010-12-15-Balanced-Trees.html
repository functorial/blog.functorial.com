<!DOCTYPE HTML>
<html><head><title>Functorial Blog - Value Lifting, Bounded Existentials and the Visitor Pattern</title><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,300|Roboto:400,700|Roboto+Condensed:400,700"><link rel="stylesheet" type="text/css" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"><link rel="stylesheet" type="text/css" href="../assets/default.css"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="text/javascript" src="../assets/gaq.js"></script></head><body><div id="container"><h1 class="text-center">Functorial Blog</h1><p class="lead text-center">A blog about functional programming</p><p class="text-center"><a href="../index.html">Home</a></p></div><section class="dark"><div class="container"><h2>Value Lifting, Bounded Existentials and the Visitor Pattern</h2><p><small>by Phil Freeman on 2010/12/15</small></p><p>Suppose we want to define a type of balanced binary trees in C#. That is, we want to define a type <code>Balanced&lt;T&gt;</code> of trees such that it is a type error to attempt to create a tree in <code>Balanced&lt;T&gt;</code> which has nodes at different depths. How might we go about this?</p>
<p>We could use nested datatypes. For example,</p>
<blockquote>
<p>Balanced T = T + Balanced (Pair T)</p>
</blockquote>
<p>However, it is hard to reason about such a type, and it is not obvious how to generalize this idea to more complex types. Also, it would be nice if we could encode the depth of a tree with its type.</p>
<p>It would be nice if we could define</p>
<blockquote>
<p>Balanced : Nat -&gt; *</p>
<p>Balanced 0 = T</p>
<p>Balanced n = Pair Balanced (n - 1)</p>
</blockquote>
<p>but we don&#39;t have the luxury of parameterizing a type with a term such as a natural number in this way.</p>
<p>What we can do is lift the values of the type Nat to singleton types:</p>
<pre><code>public interface Nat { }

public class Z : Nat { }

public class S&lt;N&gt; : Nat where N : Nat { }
</code></pre>
<p>Now we can parameterize balanced trees as follows:</p>
<pre><code>public interface BalancedTree&lt;T, N&gt; where N : Nat { }

public class Node&lt;T&gt; : BalancedTree&lt;T, Z&gt;
{
    public T Value
    {
        get;
        set;
    }
}

public class Branch&lt;T, N&gt; : BalancedTree&lt;T, S&lt;N&gt;&gt; where N : Nat
{
    public T Value
    {
        get;
        set;
    }

    public BalancedTree&lt;T, N&gt; Left
    {
        get;
        set;
    }

    public BalancedTree&lt;T, N&gt; Right
    {
        get;
        set;
    }
}
</code></pre>
<p>We now have a well-typed version of a balanced tree of a given depth. We can also wrap the natural number type parameter in an existential package to define a type of balanced trees of an unknown depth:</p>
<pre><code>public interface TreeVisitor&lt;T, R&gt;
{
    R Visit&lt;N&gt;(BalancedTree&lt;T, N&gt; e) where N : Nat;
}

public interface BalancedTree&lt;T&gt;
{
    R AcceptVisitor&lt;R&gt;(TreeVisitor&lt;T, R&gt; v);
}
</code></pre>
<p>The problem is finding a good way to get values out of the existential package. We want our functions to take different values based on the subclass of Nat appearing in the existential package. In C#, we can use the visitor pattern to distinguish behavior between subclasses. Let&#39;s alter our definition of the visitor class to branch based on the subclass of BalancedTree on the left hand side of the function:</p>
<pre><code>public interface TreeVisitor&lt;T, R&gt;
{
    R VisitEmpty(Empty&lt;T&gt; e);
    R VisitBranch&lt;N&gt;(Branch&lt;T, N&gt; b) where N : Nat;
}
</code></pre>
<p>and add methods to the tree classes to dispatch visitors to the correct subclass:</p>
<pre><code>public class Empty&lt;T&gt; : BalancedTree&lt;T, Z&gt;
{
    public R AcceptVisitor&lt;R&gt;(TreeVisitor&lt;T, R&gt; v)
    {
        return v.VisitEmpty(this);
    }


    ...
}

public class Branch&lt;T, N&gt; : BalancedTree&lt;T, S&lt;N&gt;&gt; where N : Nat
{
    public R AcceptVisitor&lt;R&gt;(TreeVisitor&lt;T, R&gt; v)
    {
        return v.VisitBranch&lt;N&gt;(this);
    }

    ...
}
</code></pre>
<p>Now we can define methods on our existential type using the visitor pattern. For example, here is a map which takes a balanced tree and flattens it into a list:</p>
<pre><code>class FlattenVisitor&lt;T&gt; : TreeVisitor&lt;T, IEnumerable&lt;T&gt;&gt;
{
    public IEnumerable&lt;T&gt; VisitEmpty(Empty&lt;T&gt; e)
    {
        yield return Value;
    }

    public IEnumerable&lt;T&gt; VisitBranch&lt;N&gt;(Branch&lt;T, N&gt; b) where N : Nat
    {
        var leftList = b.Left.AcceptVisitor&lt;IEnumerable&lt;T&gt;&gt;(this);
        var rightList = b.Right.AcceptVisitor&lt;IEnumerable&lt;T&gt;&gt;(this);
        return leftList.Concat(rightList);

    }

}

public static IEnumerable&lt;T&gt; Flatten&lt;T&gt;(this BalancedTree&lt;T&gt; b)
{
    return b.AcceptVisitor&lt;IEnumerable&lt;T&gt;&gt;(new FlattenVisitor&lt;T&gt;());
}
</code></pre>
<p>We can also forget the depth of a tree by wrapping it in an existential package:</p>
<pre><code>class ForgetfulTree&lt;T, N&gt; : BalancedTree&lt;T&gt; where N : Nat
{
    private readonly BalancedTree&lt;T, N&gt; b;

    public ForgetfulTree(BalancedTree&lt;T, N&gt; b)
    {
        this.b = b;
    }

    public R AcceptVisitor&lt;R&gt;(TreeVisitor&lt;T, R&gt; v)
    {
        return b.AcceptVisitor&lt;R&gt;(v);
    }
}
 

public static BalancedTree&lt;T&gt; Forget&lt;T, N&gt;(this BalancedTree&lt;T, N&gt; b) where N : Nat
{
    return new ForgetfulTree&lt;T, N&gt;(b);
}
</code></pre>
<p>Finally, here is an example calculation:</p>
<pre><code>BalancedTree&lt;int, S&lt;S&lt;S&lt;Z&gt;&gt;&gt;&gt; treeOfKnownDepth =
    new Branch&lt;int, S&lt;S&lt;Z&gt;&gt;&gt;
{
    Left = new Branch&lt;int, S&lt;Z&gt;&gt;
    {
        Left = new Branch&lt;int, Z&gt;
        {
            Left = new Empty&lt;int&gt; { Value = 1 },
            Right = new Empty&lt;int&gt; { Value = 2 }
        },
        Right = new Branch&lt;int, Z&gt;
        {
            Left = new Empty&lt;int&gt; { Value = 3 },
            Right = new Empty&lt;int&gt; { Value = 4 }
        }
    },
    Right = new Branch&lt;int, S&lt;Z&gt;&gt;
    {
        Left = new Branch&lt;int, Z&gt;
        {
            Left = new Empty&lt;int&gt; { Value = 5 },
            Right = new Empty&lt;int&gt; { Value = 6 }
        },
        Right = new Branch&lt;int, Z&gt;
        {
            Left = new Empty&lt;int&gt; { Value = 7 },
            Right = new Empty&lt;int&gt; { Value = 8 }
        }
    }
}
</code></pre>
<p>We can take this &#39;tree of known depth&#39; and forget its depth:</p>
<blockquote>
<p>var treeOfUnknownDepth = treeOfKnownDepth.Forget();</p>
</blockquote>
<p>We can then calculate:</p>
<blockquote>
<p>treeOfUnknownDepth.Flatten();</p>
<p>[ 1, 2, 3, 4, 5, 6, 7, 8 ]</p>
</blockquote>
</div></section><div class="container"><p class="text-center text-muted"><small>Copyright Phil Freeman 2010-2015</small></p></div></body></html>