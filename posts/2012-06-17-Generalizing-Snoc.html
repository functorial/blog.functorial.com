<!DOCTYPE HTML>
<html><head><title>Functorial Blog - Generalizing O(1) Snoc On Lists</title><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,300|Roboto:400,700|Roboto+Condensed:400,700"><link rel="stylesheet" type="text/css" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"><link rel="stylesheet" type="text/css" href="../assets/default.css"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="text/javascript" src="../assets/gaq.js"></script></head><body><div id="container"><h1 class="text-center">Functorial Blog</h1><p class="lead text-center">A blog about functional programming</p><p class="text-center"><a href="../index.html">Home</a></p></div><section class="dark"><div class="container"><h2>Generalizing O(1) Snoc On Lists</h2><p><small>by Phil Freeman on 2012/06/17</small></p><p>I&#39;ve recently been thinking about how to generalize an efficient version of the <code>snoc</code> operation on lists.</p>
<p>Specifically, one can represent lists by identifying them with their fold functions:</p>
<pre><code>-- data List a = List { fold :: forall r. r -&gt; (a -&gt; r -&gt; r) -&gt; r }
</code></pre>
<p>This representation, as in the case of difference lists, admits efficient versions of the cons operation at both ends of the list:</p>
<pre><code>-- cons :: a -&gt; List a -&gt; List a
-- cons a l = List (\r0 acc -&gt; acc a $ fold l r0 acc)

-- snoc :: a -List a -&gt; List a
-- snoc a l = List (\r0 acc -&gt; fold l (acc a r0) acc)
</code></pre>
<p>I wondered if it was possible to generialize this to arbitrary least fixed point types. What I came up with is satisfactory, but I wonder if there is a better generalization of the original <code>snoc</code> function.</p>
<p>We&#39;ll need these imports and extensions:</p>
<pre class="{.haskell}"><code>{-# LANGUAGE RankNTypes, DeriveFunctor, DeriveFoldable, DeriveTraversable #-}

import qualified Data.Void as V
import qualified Data.Monoid as M
import qualified Data.Foldable as F
import qualified Data.Traversable as T
</code></pre>
<p>First, let&#39;s generalize the type <code>List</code> given above to any type constructor <code>f</code>:</p>
<pre class="{.haskell}"><code>newtype Rec f = Rec { cata :: forall r. (f r -&gt; r) -&gt; r }
</code></pre>
<p>The <code>cons</code> operation is easily generalized - <code>Rec f</code> is an initial <code>f</code>-algebra, and the algebra map gives the generalization of <code>cons</code>:</p>
<pre class="{.haskell}"><code>gcons :: (Functor f) =&gt; f (Rec f) -&gt; Rec f
gcons x = Rec cata&#39; where
  cata&#39; phi = phi $ fmap (flip cata phi) x
</code></pre>
<p>Generalizing <code>snoc</code> is a little less obvious. I came up with the following.</p>
<p>What I&#39;d like to do is to replace the leaves of the recursive structure with one more level of <code>f</code>-structure. By &quot;leaves&quot; I mean values of <code>Rec f</code> with no structurally smaller elements. These are given by the summands in <code>(f x)</code> with no factor of <code>x</code>. In other words, the type of leaves of <code>f</code> is given by applying <code>f</code> to the empty type <code>Void</code>.</p>
<p>Given a <code>Traversable</code> instance for <code>f</code>, we can attempt to convert a value into a leaf by replacing all instances of the type <code>a</code> by <code>Nothing</code>, and then collapsing the structure to a single <code>Maybe</code> value using <code>mapM</code>:</p>
<pre class="{.haskell}"><code>toLeaf :: (Functor f, T.Traversable f) =&gt; f a -&gt; Maybe (f V.Void)
toLeaf = T.mapM (const Nothing)
</code></pre>
<p>Now we can define a generalized version of the <code>snoc</code> method above. <code>gsnoc</code> takes a function which replaces leaves with an additional level of <code>f</code>-structure, and applies it only to the leaves:</p>
<pre class="{.haskell}"><code>gsnoc :: (Functor f, T.Traversable f) =&gt; (forall r. f V.Void -&gt; f (f V.Void)) -&gt; Rec f -&gt; Rec f
gsnoc f x = Rec cata&#39; where
  cata&#39; phi = cata x (phi&#39; phi)
  phi&#39; phi y = case toLeaf y of 
    Nothing -&gt; phi y
    (Just leaf) -&gt; phi $ fmap (($) phi . fmap V.absurd) $ f leaf
</code></pre>
<p><code>gsnoc</code> is also easily seen to be an O(1) operation, independent of the size of its input.</p>
<p>Now let&#39;s see some examples. First, we&#39;ll recover the usual O(1) snoc operation on lists.</p>
<pre class="{.haskell}"><code>data ListF a x = Nil | Cons a x deriving (Functor, F.Foldable, T.Traversable)

type List a = Rec (ListF a)
</code></pre>
<p>We can define two constructor functions and a single destructor which will help when working with this representation of lists:</p>
<pre class="{.haskell}"><code>nil :: List a
nil = gcons Nil

cons :: a -&gt; List a -&gt; List a
cons a l = gcons $ Cons a l

toList :: List a -&gt; [a]
toList = flip cata toList&#39; where
  toList&#39; Nil = []
  toList&#39; (Cons a l) = a:l
</code></pre>
<p>We can create a list of three elements and append an element to its tail:</p>
<pre class="{.haskell}"><code>test1 :: List Int
test1 = cons 1 $ cons 2 $ cons 3 nil

test2 :: List Int
test2 = gsnoc (Cons 4) test1

-- toList test2
-- [1,2,3,4]
</code></pre>
<p>Now let&#39;s try a different recursive datatype - the type of binary trees:</p>
<pre class="{.haskell}"><code>data TreeF a x = Tip | Branch x a x deriving (Functor, F.Foldable, T.Traversable)

type Tree a = Rec (TreeF a)
</code></pre>
<p>Again, we can define helper methods to construct and destruct trees. This time, the method flattenTree with perform an in-order traversal of the tree to collapse the tree down to a single list:</p>
<pre class="{.haskell}"><code>tip :: Tree a
tip = gcons Tip

branch :: Tree a -&gt; a -&gt; Tree a -&gt; Tree a
branch l a r = gcons $ Branch l a r

flattenTree :: Tree a -&gt; [a]
flattenTree = flip cata flattenTree&#39; where
  flattenTree&#39; Tip = []
  flattenTree&#39; (Branch l a r) = l ++ [a] ++ r
</code></pre>
<p>This time, <code>Tip</code> is the only type of leaf, and the <code>snoc</code> method will replace a <code>Tip</code> constructor with a <code>Branch</code>:</p>
<pre class="{.haskell}"><code>snocTree :: a -&gt; r -&gt; TreeF a r
snocTree a r = Branch r a r

test3 :: Tree Int
test3 = branch tip 1 (branch (branch tip 3 tip) 2 (branch tip 4 tip))

test4 :: Tree Int
test4 = gsnoc (snocTree 5) test3

-- flattenTree test4
-- [5,1,5,3,5,2,5,4,5]
</code></pre>
<p>Finally, we can also generalize the O(1) append method on lists, by replacing leaves with a whole new structure. Again, we require a <code>Traversable</code> instance as well as a <code>Functor</code> instance for <code>f</code>:</p>
<pre class="{.haskell}"><code>gappend :: (Functor f, T.Traversable f) =&gt; (f V.Void -&gt; Rec f) -&gt; Rec f -&gt; Rec f
gappend f x = Rec cata&#39; where
  cata&#39; phi = cata x (phi&#39; phi)
  phi&#39; phi y = case toLeaf y of 
    Nothing -&gt; phi y
    (Just leaf) -&gt; cata (f leaf) phi
</code></pre>
<p>On lists, the generalized <code>append</code> function does what one would expect:</p>
<pre><code>-- toList $ gappend (const test1) test1
-- [1,2,3,1,2,3]
</code></pre>
<p>On trees, <code>gappend</code> replaces each <code>Tip</code> with a new tree:</p>
<pre><code>-- flattenTree $ gappend (const test3) test3
-- [1,3,2,4,1,1,3,2,4,3,1,3,2,4,2,1,3,2,4,4,1,3,2,4]
</code></pre>
</div></section><div class="container"><p class="text-center text-muted"><small>Copyright Phil Freeman 2010-2015</small></p></div></body></html>